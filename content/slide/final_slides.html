---
title: "Visualizing Clusters with Iris"
author: "Darrick Sturgeon"
date: "June 18, 2018"
output: xaringan::moon_reader
---



<p>class: inverse # The Dataset</p>
<p>I chose the cran built-in iris dataset.</p>
<div class="figure">
<img src="https://s3.amazonaws.com/assets.datacamp.com/blog_assets/Machine+Learning+R/iris-machinelearning.png" alt="Iris Dataset" />
<p class="caption">Iris Dataset</p>
</div>
<p>This dataset is a very nice dataset for clustering.</p>
<p>Sorry for choosing an easy dataset! I had meant to work through the visualization first and repeat this with a more interesting example.</p>
<p>class: inverse # The Objective</p>
<p>The goal is to explore the data using clustering methods. To do this, we will employ and visualize a Gaussian Mixture Model, we will also employ Principal Component Analysis to (hopefully) give the best view of the clusters.</p>
<p>GMMs for clustering can be effective in cases where the data:</p>
<p>–</p>
<ul>
<li>has or is expected to have groupings, classes, or some sort of separability</li>
</ul>
<p>–</p>
<ul>
<li>consists of several continuous variables</li>
</ul>
<p>–</p>
<ul>
<li>has a comfortably large number of observations</li>
</ul>
<p>–</p>
<ul>
<li>preferably no missing data</li>
</ul>
<p>class: inverse # The Setup</p>
<p>GMMs can be done in R using the package “mixtools”. Unfortunately, the package is not conformed to the tidyverse so you end up with some nested lists as outputs instead of dataframes. There is also a package “mclust”, which is possibly a better choice in terms of features or organization (I haven’t had the chance to try it).</p>
<pre><code>number of iterations= 32 </code></pre>
<pre class="r"><code>pca &lt;- prcomp(data, scale=TRUE, center=TRUE)
comps &lt;- data.frame(pca$x)
colnames(comps) &lt;- c(&#39;pc1&#39;, &#39;pc2&#39;, &#39;pc3&#39;, &#39;pc4&#39;)
comps$Species &lt;- iris$Species
comps &lt;- rbind(comps[idx,], comps[-idx,])</code></pre>
<pre class="r"><code>tmp &lt;- as.data.frame(mvn$posterior)  %&gt;% 
  mutate(cls=apply(.[,], 1, function(x) names(x)[which.max(x)])) %&gt;% 
  select(cls) %&gt;%
  mutate(train = &#39;TRAIN&#39;)

tmp2 &lt;- t(classify(as.matrix(test)))
colnames(tmp2) &lt;- c(&#39;comp.1&#39;, &#39;comp.2&#39;, &#39;comp.3&#39;)
tmp2 &lt;- as.data.frame(tmp2) %&gt;%
  mutate(cls=apply(.[,], 1, function(x) names(x)[which.max(x)])) %&gt;% 
  select(cls) %&gt;%
  mutate(train = &#39;TEST&#39;)</code></pre>
<pre class="r"><code>tm &lt;- rbind(tmp, tmp2)
comps$cls &lt;- tm$cls
comps$train &lt;- tm$train
comps &lt;- comps %&gt;% mutate(cls = factor(cls))
comps &lt;- comps %&gt;% mutate(correct = case_when(Species == &#39;setosa&#39; &amp; cls == &#39;comp.1&#39; ~ TRUE,
                           Species == &#39;versicolor&#39; &amp; cls == &#39;comp.2&#39; ~ TRUE,
                           Species == &#39;virginica&#39; &amp; cls == &#39;comp.3&#39; ~ TRUE,
                           TRUE ~ FALSE))
iris2 &lt;- rbind(iris[idx,], iris[-idx,])
iris2$cls &lt;- comps$cls
iris2$train &lt;- comps$train
iris2 &lt;- iris2 %&gt;% mutate(cls = factor(cls))
iris2$correct &lt;- comps$correct</code></pre>
<p>class: inverse # Plot 1.0</p>
<p><img src="/slide/final_slides_files/figure-html/unnamed-chunk-5-1.png" width="1008" /></p>
<p>class: inverse # How to Read It and What to Look For</p>
<p>This is a scatter plot with two things added: Some information about the distributions found by the model, which are multivariate gaussians, and information about the classification encoded into shape and color.</p>
<p>While not explicitly stated due to legend difficulties, The solid and dotted lines respectively represent the 1 standard deviation (68%) and 2 standard deviation (97%) levels for the respective multivariate gaussian.</p>
<p>The true class is represented by shape, and the predicted class is represented by the color, which matches the color of the associated gaussian. The red circles help draw the eye two where a shape/color mismatch has occurred.</p>
<p>class: inverse # How to make it even better</p>
<p>You can actually compute the curves where the gaussian level sets intersect, meaning we could show the class decision boundaries. These are very cool plots but obviously take a bit more time to set up.</p>
<p>There are two annotations I would add: accuracy to both plots, and either a legend or annotations for the gaussian level sets.</p>
<p>I still don’t know the best way to visualize true classes vs. predicted classes, I thought this did a fairly good job, but if the number of clusters increases by much… 6 different shapes may get horrendous. In the end, I think maybe three plots may do the trick: True class, predicted class, highlighted misclassifications (everything else grey). These in succession would be extremely clear.</p>
<hr />
<p>class: inverse</p>
<div id="issuesobservations" class="section level1">
<h1>Issues/Observations</h1>
<p>Adding ‘linestyle’ to the legend proved rather difficult, as the two types of line plotted: solid and dashed, were really not based on any facet of the data. This proves quite difficult for ggplot, where most suggestions are to simply hack the plot to have such a distinction, e.g., adding a geom_line with alpha=0. I tried this and it did not work as intended.</p>
<p>ggplot doesn’t offer anything too nice for geometric shapes. The “stat_ellipse” function allows you to fit a normal distribution to a set of data and draw the level curves around it. This is actually equivalent to the solution for the GMM if you “color” by the classes output from the GMM. If, for some reason, stat_ellipse didn’t give the precise ellipses you were seeking, or you wish to plot some other curve, you would have to plot the two (upper and lower) curves for each ellipse. Basically, a lot of algebra for the average user.</p>
</div>
